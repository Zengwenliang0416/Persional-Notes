# 责任链模式详解

## 一、什么是责任链模式？

责任链模式（Chain of Responsibility Pattern）是一种行为设计模式，它允许将请求沿着一个处理链传递，直到链中的某个对象处理它。这种模式使得发送者无需知道哪个对象将处理请求，所有的处理对象都可以尝试处理请求或将请求传递给链上的下一个对象。

### 核心思想
- 将请求的发送者与接收者解耦
- 通过让多个对象组成一条链
- 使得请求沿着链传递，直到被处理

## 二、责任链模式的特点

1. **解耦请求发出者和处理者**
   - 请求的发送者不需要知道具体的处理者
   - 增强了系统的灵活性和扩展性

2. **动态组合处理逻辑**
   - 可以根据需要动态改变链的结构
   - 添加或移除处理者更加灵活

3. **职责单一**
   - 每个验证逻辑封装到独立的处理器中
   - 每个处理器负责单一的验证职责
   - 符合单一职责原则

4. **可扩展性**
   - 增加新的验证逻辑只需继承统一接口
   - 添加新的处理器无需修改现有代码

5. **清晰的流程**
   - 将所有验证逻辑组织在一起
   - 代码结构更加清晰，易于理解

## 三、责任链模式和策略模式结合的意义

### 责任链模式的作用
- 用于动态处理请求
- 将多个处理逻辑串联起来

### 策略模式的作用
- 用于封装一组算法
- 在运行时动态选择需要的算法

### 结合两者的优势
1. 责任链模式负责串联和传递请求
2. 策略模式定义每个处理者的具体处理逻辑
3. 两者结合可以实现：
   - 动态构建责任链
   - 灵活应用不同策略来处理请求

## 四、责任链模式解决的问题

1. **耦合过高**
   - 将请求的处理者从发送者中解耦
   - 处理者可以独立扩展或变更

2. **复杂的多条件判断**
   - 避免使用过多 if-else 或 switch-case 语句
   - 使代码更加清晰和易维护

3. **灵活性不足**
   - 通过链的动态组合调整请求传递逻辑
   - 方便插入新的处理者

4. **代码重复**
   - 每个处理者只专注于处理它关心的部分
   - 减少重复代码

## 五、代码实现示例

### 1. 商品上架逻辑实现

#### 1.1 定义责任链抽象接口
```java
public interface MerchantAdminAbstractChainHandler<T> extends Ordered {
    /**
     * 执行责任链逻辑
     */
    void handler(T requestParam);

    /**
     * 责任链组件标识
     */
    String mark();
}
```

#### 1.2 定义商品上架的责任链标识
```java
public enum ChainBizMarkEnum {
    MERCHANT_ADMIN_CREATE_PRODUCT_TEMPLATE_KEY,
    MERCHANT_ADMIN_PRODUCT_UPSHELF_KEY; // 商品上架责任链标识
}
```

#### 1.3 责任链上下文实现
```java
@Component
public final class MerchantAdminChainContext<T> implements ApplicationContextAware, CommandLineRunner {
    private ApplicationContext applicationContext;
    private final Map<String, List<MerchantAdminAbstractChainHandler>> abstractChainHandlerContainer = new HashMap<>();

    public void handler(String mark, T requestObj) {
        List<MerchantAdminAbstractChainHandler> handlers = abstractChainHandlerContainer.get(mark);
        if (CollectionUtils.isEmpty(handlers)) {
            throw new RuntimeException(String.format("[%s] Chain of Responsibility ID is undefined.", mark));
        }
        handlers.forEach(each -> each.handler(requestObj));
    }

    @Override
    public void run(String... args) {
        Map<String, MerchantAdminAbstractChainHandler> chainFilterMap = 
            applicationContext.getBeansOfType(MerchantAdminAbstractChainHandler.class);
        
        chainFilterMap.forEach((beanName, bean) -> {
            List<MerchantAdminAbstractChainHandler> handlers = 
                abstractChainHandlerContainer.getOrDefault(bean.mark(), new ArrayList<>());
            handlers.add(bean);
            abstractChainHandlerContainer.put(bean.mark(), handlers);
        });

        abstractChainHandlerContainer.forEach((mark, chainHandlers) -> 
            chainHandlers.sort(Comparator.comparing(Ordered::getOrder)));
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }
}
```

#### 1.4 具体处理器实现
```java
@Component
public class ProductInfoNotNullChainFilter implements MerchantAdminAbstractChainHandler<ProductUpShelfReqDTO> {
    @Override
    public void handler(ProductUpShelfReqDTO requestParam) {
        if (StringUtils.isEmpty(requestParam.getProductName())) {
            throw new RuntimeException("商品名称不能为空！");
        }
        if (requestParam.getPrice() == null || requestParam.getPrice() <= 0) {
            throw new RuntimeException("商品价格必须大于0！");
        }
        System.out.println("商品信息非空校验通过");
    }

    @Override
    public int getOrder() {
        return 1;
    }

    @Override
    public String mark() {
        return ChainBizMarkEnum.MERCHANT_ADMIN_PRODUCT_UPSHELF_KEY.name();
    }
}

@Component
public class ProductInventoryCheckChainFilter implements MerchantAdminAbstractChainHandler<ProductUpShelfReqDTO> {
    @Override
    public void handler(ProductUpShelfReqDTO requestParam) {
        if (requestParam.getStock() <= 0) {
            throw new RuntimeException("商品库存不足，无法上架！");
        }
        System.out.println("商品库存校验通过");
    }

    @Override
    public int getOrder() {
        return 2;
    }

    @Override
    public String mark() {
        return ChainBizMarkEnum.MERCHANT_ADMIN_PRODUCT_UPSHELF_KEY.name();
    }
}
```

#### 1.5 业务服务实现
```java
@Service
@RequiredArgsConstructor
public class ProductServiceImpl {
    private final MerchantAdminChainContext<ProductUpShelfReqDTO> merchantAdminChainContext;

    public void upShelfProduct(ProductUpShelfReqDTO requestParam) {
        // 调用责任链进行校验
        merchantAdminChainContext.handler(
            ChainBizMarkEnum.MERCHANT_ADMIN_PRODUCT_UPSHELF_KEY.name(),
            requestParam
        );
        System.out.println("商品上架逻辑开始执行...");
        // 后续的商品上架业务逻辑
    }
}
```

### 2. 责任链+策略模式完整示例

#### 2.1 定义请求处理接口
```java
public interface RequestHandler {
    void setNextHandler(RequestHandler nextHandler);
    void handleRequest(UserRequest request);
}
```

#### 2.2 定义用户请求类
```java
public class UserRequest {
    private String userType;
    private String requestContent;

    public UserRequest(String userType, String requestContent) {
        this.userType = userType;
        this.requestContent = requestContent;
    }

    public String getUserType() {
        return userType;
    }

    public String getRequestContent() {
        return requestContent;
    }
}
```

#### 2.3 定义策略接口及实现
```java
public interface RequestStrategy {
    void process(UserRequest request);
}

public class BasicUserStrategy implements RequestStrategy {
    @Override
    public void process(UserRequest request) {
        System.out.println("普通用户的请求正在处理：" + request.getRequestContent());
    }
}

public class AdminUserStrategy implements RequestStrategy {
    @Override
    public void process(UserRequest request) {
        System.out.println("管理员的请求正在处理：" + request.getRequestContent());
    }
}

public class SuperAdminStrategy implements RequestStrategy {
    @Override
    public void process(UserRequest request) {
        System.out.println("高级管理员的请求正在处理：" + request.getRequestContent());
    }
}
```

#### 2.4 实现具体处理者
```java
public class RequestHandlerImpl implements RequestHandler {
    private RequestStrategy strategy;
    private RequestHandler nextHandler;

    public RequestHandlerImpl(RequestStrategy strategy) {
        this.strategy = strategy;
    }

    @Override
    public void setNextHandler(RequestHandler nextHandler) {
        this.nextHandler = nextHandler;
    }

    @Override
    public void handleRequest(UserRequest request) {
        strategy.process(request);
        if (nextHandler != null) {
            nextHandler.handleRequest(request);
        }
    }
}
```

#### 2.5 测试代码
```java
public class ChainStrategyExample {
    public static void main(String[] args) {
        // 创建策略
        RequestStrategy basicStrategy = new BasicUserStrategy();
        RequestStrategy adminStrategy = new AdminUserStrategy();
        RequestStrategy superAdminStrategy = new SuperAdminStrategy();

        // 创建责任链处理者
        RequestHandler basicHandler = new RequestHandlerImpl(basicStrategy);
        RequestHandler adminHandler = new RequestHandlerImpl(adminStrategy);
        RequestHandler superAdminHandler = new RequestHandlerImpl(superAdminStrategy);

        // 设置责任链
        basicHandler.setNextHandler(adminHandler);
        adminHandler.setNextHandler(superAdminHandler);

        // 测试请求
        UserRequest basicRequest = new UserRequest("普通用户", "请求访问资源 A");
        System.out.println("处理普通用户请求：");
        basicHandler.handleRequest(basicRequest);

        UserRequest adminRequest = new UserRequest("管理员", "请求修改资源 B");
        System.out.println("\n处理管理员请求：");
        adminHandler.handleRequest(adminRequest);

        UserRequest superAdminRequest = new UserRequest("高级管理员", "请求删除资源 C");
        System.out.println("\n处理高级管理员请求：");
        superAdminHandler.handleRequest(superAdminRequest);
    }
}
```

## 六、责任链模式和策略模式结合的优势

### 1. 流程控制与处理逻辑分离
- 责任链控制请求的流转过程
- 策略定义具体的处理逻辑
- 两者各司其职，职责明确

### 2. 职责分离
- 责任链专注于请求的传递
- 策略模式专注于业务逻辑实现
- 代码结构清晰，易于维护

### 3. 灵活性和可扩展性
- 责任链可以动态调整处理流程
- 策略可以灵活替换处理逻辑
- 系统适应性强，易于扩展

### 4. 代码复用
- 策略可以在不同的责任链中复用
- 处理逻辑可以组合使用
- 提高代码复用率

## 总结

责任链模式与策略模式的结合是一种强大的设计模式组合，它既保持了代码的灵活性和可扩展性，又保证了系统的高内聚低耦合。这种组合特别适合处理复杂的业务流程，如审批流程、数据校验等场景。通过合理运用这两种模式，可以构建出更加健壮和易维护的系统。 