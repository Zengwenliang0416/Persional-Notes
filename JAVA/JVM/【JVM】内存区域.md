# JVM 内存区域详解

## 目录
[1. 目录](#目录)
[2. 一、运行时数据区域](#一运行时数据区域)
    [2.1 程序计数器（Program Counter Register）](#程序计数器program-counter-register)
    [2.2 Java 虚拟机栈（Java Virtual Machine Stack）](#java-虚拟机栈java-virtual-machine-stack)
    [2.3 本地方法栈（Native Method Stack）](#本地方法栈native-method-stack)
    [2.4 Java 堆（Java Heap）](#java-堆java-heap)
    [2.5 方法区（Method Area）](#方法区method-area)
    [2.6 运行时常量池（Runtime Constant Pool）](#运行时常量池runtime-constant-pool)
[3. 二、内存分配策略](#二内存分配策略)
    [3.1 对象优先在 Eden 分配](#对象优先在-eden-分配)
    [3.2 大对象直接进入老年代](#大对象直接进入老年代)
    [3.3 长期存活的对象进入老年代](#长期存活的对象进入老年代)
    [3.4 动态对象年龄判定](#动态对象年龄判定)
[4. 三、垃圾收集](#三垃圾收集)
    [4.1 判断对象是否存活](#判断对象是否存活)
    [4.2 垃圾收集算法](#垃圾收集算法)
[5. 四、常见问题及优化](#四常见问题及优化)
    [5.1 内存泄漏](#内存泄漏)
    [5.2 性能优化](#性能优化)
[6. 五、监控与工具](#五监控与工具)
    [6.1 JVM 监控工具](#jvm-监控工具)
    [6.2 可视化工具](#可视化工具)



## 一、运行时数据区域

JVM 在执行 Java 程序时会把它所管理的内存划分为若干个不同的数据区域：

### 程序计数器（Program Counter Register）

- **定义**：当前线程所执行的字节码的行号指示器
- **特点**：
  - 线程私有
  - 占用内存空间很小
  - 是唯一一个在 JVM 规范中没有规定任何 OutOfMemoryError 的区域
- **作用**：
  - 字节码解释器通过改变计数器的值来选取下一条需要执行的字节码指令
  - 在多线程情况下，程序计数器用于记录当前线程执行的位置

### Java 虚拟机栈（Java Virtual Machine Stack）

- **定义**：描述 Java 方法执行的内存模型
- **特点**：
  - 线程私有
  - 生命周期与线程相同
- **组成**：由多个栈帧（Stack Frame）组成
  - 局部变量表
  - 操作数栈
  - 动态链接
  - 方法出口等
- **异常**：
  - StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度
  - OutOfMemoryError：栈扩展时无法申请到足够的内存

### 本地方法栈（Native Method Stack）

- **定义**：为虚拟机使用到的 Native 方法服务
- **特点**：
  - 线程私有
  - HotSpot 虚拟机将本地方法栈和虚拟机栈合二为一
- **异常**：同虚拟机栈

### Java 堆（Java Heap）

- **定义**：存放对象实例的区域
- **特点**：
  - 线程共享
  - 虚拟机启动时创建
  - 垃圾收集器管理的主要区域（"GC 堆"）
- **分代**（HotSpot 中的实现）：
  - 新生代
    - Eden 空间
    - From Survivor 空间
    - To Survivor 空间
  - 老年代
- **异常**：OutOfMemoryError，当堆中没有内存完成实例分配，并且堆也无法再扩展时

### 方法区（Method Area）

- **定义**：存储已被虚拟机加载的类型信息、常量、静态变量等数据
- **特点**：
  - 线程共享
  - 在 HotSpot 虚拟机中，方法区也被称为"永久代"（JDK 8 之前）
- **存储内容**：
  - 类型信息（类名、访问修饰符等）
  - 方法信息
  - 字段信息
  - 运行时常量池
- **演进**：
  - JDK 7：已经开始将字符串常量池、静态变量等从永久代中移出
  - JDK 8：完全废弃永久代，改用元空间（Metaspace）

### 运行时常量池（Runtime Constant Pool）

- **定义**：方法区的一部分，Class 文件中的常量池表（Constant Pool Table）
- **特点**：
  - 动态性：运行期间也可以将新的常量放入池中
  - 受方法区内存的限制
- **内容**：
  - 字面量
  - 符号引用

## 二、内存分配策略

### 对象优先在 Eden 分配

- 大多数情况下，对象在新生代 Eden 区分配
- 当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC

### 大对象直接进入老年代

- 大对象：需要大量连续内存空间的对象
- 通过 `-XX:PretenureSizeThreshold` 参数设置

### 长期存活的对象进入老年代

- 对象年龄计数器
- 通过 `-XX:MaxTenuringThreshold` 参数设置

### 动态对象年龄判定

- 如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半
- 年龄大于或等于该年龄的对象直接进入老年代

## 三、垃圾收集

### 判断对象是否存活

- **引用计数算法**
  - 优点：实现简单，判定效率高
  - 缺点：无法解决循环引用问题
  
- **可达性分析算法**
  - GC Roots
  - 对象引用链

### 垃圾收集算法

1. **标记-清除算法（Mark-Sweep）**
   - 标记阶段：标记所有需要回收的对象
   - 清除阶段：回收被标记的对象
   - 缺点：产生大量内存碎片

2. **复制算法（Copying）**
   - 将内存分为两块
   - 优点：实现简单，运行高效
   - 缺点：内存利用率低

3. **标记-整理算法（Mark-Compact）**
   - 标记阶段：与标记-清除算法一样
   - 整理阶段：让所有存活对象向内存空间一端移动

4. **分代收集算法（Generational Collection）**
   - 新生代：复制算法
   - 老年代：标记-清除或标记-整理算法

## 四、常见问题及优化

### 内存泄漏

- **常见原因**：
  - 静态集合类
  - 未关闭的资源
  - 内部类持有外部类引用
  - ThreadLocal 使用不当

- **解决方案**：
  - 使用完毕的对象设为 null
  - 使用 WeakReference
  - 及时关闭资源
  - 注意内部类的静态声明

### 性能优化

- **JVM 参数调优**：
  - `-Xms`：初始堆大小
  - `-Xmx`：最大堆大小
  - `-XX:NewRatio`：新生代和老年代的比值
  - `-XX:SurvivorRatio`：Eden 区和 Survivor 区的比值

- **代码层面优化**：
  - 合理使用对象池
  - 及时释放不再使用的对象
  - 避免创建过多临时对象
  - 使用 StringBuilder 代替 String 的拼接操作

## 五、监控与工具

### JVM 监控工具

- **jps**：显示当前所有 Java 进程的 PID
- **jstat**：监视虚拟机各种运行状态信息
- **jmap**：生成堆转储快照
- **jhat**：分析堆转储快照
- **jstack**：生成虚拟机当前时刻的线程快照

### 可视化工具

- **JConsole**：Java 监视与管理控制台
- **VisualVM**：多合一故障处理工具
- **MAT**：内存分析工具
- **Arthas**：Alibaba 开源的 Java 诊断工具